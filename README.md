# 데이터베이스 인덱스 최대 길이 제한으로 인한 varchar 컬럼 길이 조정 사례

## 문제 배경
팀원 한 분이 맡은 원격 로그아웃 기능을 구현하던 중, 개발 서버에 배포 후 간헐적으로 로그인이 실패하는 현상이 발생했습니다. 저희 팀은 JWT 토큰 기반 로그인 시스템을 사용하고 있으며, 원격 로그아웃 기능을 지원하기 위해 로그인 정보를 저장하는 테이블에 `session_token` 컬럼을 `varchar(512)`로 정의하여 JWT 토큰을 저장하고 있었습니다. 그러나 특정 상황에서 로그인이 정상적으로 이루어지지 않는 문제를 발견하게 되었습니다.

## 문제 원인 분석
이슈를 디버깅하던 중, 로그인이 실패하는 경우 `session_token` 컬럼의 길이 제한(512자)으로 인해 JWT 토큰이 잘려서 데이터베이스에 저장되고 있음을 확인했습니다. 이로 인해 로그인 정보를 조회하는 쿼리가 토큰을 정확히 매핑하지 못해 실패했습니다. 해당 쿼리는 다음과 같이 정의되어 있었습니다:
```
// 쿼리 로직 일부
SELECT {columns} FROM {table_name}
WHERE {다른 조건} session_token = '<full_token_value>';
```
하지만 데이터베이스에 저장된 값은 길이 제한으로 인해 문자열이 잘려 저장되어, 전체 토큰 정보와 일치하지 않아 조회가 불가능했던 것입니다.

## 초기 대응 및 발생한 오류
문제를 신속히 해결하기 위해 session_token 컬럼의 길이를 두 배인 `varchar(1024)`로 늘리려 했으나, 컬럼 길이 변경 시 다음과 같은 에러가 발생했습니다:
> [42000][1071] Specified key was too long; max key length is 3072 bytes.

이 에러는 데이터베이스 인덱스의 최대 키 길이 제한(3072바이트)을 초과했음을 나타냅니다. 추가 조사 결과, `session_token` 컬럼은 아래와 같이 정의된 복합 인덱스에 포함되어 있어 키 길이 제한에 영향을 받고 있었습니다.
```
CREATE INDEX {index_name}
ON {table_name} (team_id, user_id, session_token, expired_at, login_at);
```

## 인덱스 길이 제한 분석
데이터베이스(MySQL 기준)에서 인덱스의 최대 키 길이는 3072바이트로 제한됩니다. 따라서 인덱스에 포함된 모든 컬럼의 바이트 합계가 이 값을 초과하면 안 됩니다. 현재 테이블의 문자셋은 `utf8mb3(UTF-8의 3바이트 버전)`로 설정되어 있으며, 각 컬럼의 바이트 수는 다음과 같이 계산됩니다.
- team_id (int): 4바이트
- user_id (int): 4바이트
- session_token (varchar(n)): n × 3 바이트 (utf8mb3에서 한 문자가 최대 3바이트)
- expired_at (timestamp): 4바이트
- login_at (timestamp): 4바이트

인덱스의 총 바이트 수는 다음과 같은 식으로 표현됩니다.

> 총 바이트 수 = 4 + 4 + (n × 3) + 4 + 4 = 16 + (n × 3)

이 값이 3072바이트 이하여야 하므로, 최대 허용 길이를 계산하면

> 16 + (n × 3) ≤ 3072
> 
> n × 3 ≤ 3072 − 16
> 
> n × 3 ≤ 3056
> 
> n ≤ (3056 / 3) ≈ 1018.666

소수점 이하는 버림 처리되므로, `session_token` 컬럼의 최대 길이는 `varchar(1018)`로 설정 가능합니다.

## 단기적 해결 방안
위 계산을 바탕으로 `session_token` 컬럼의 길이를 `varchar(1018)`로 변경했습니다. 이를 통해 JWT 토큰이 잘리지 않고 전체 길이로 저장될 수 있게 되었으며, 로그인 조회 쿼리가 정상적으로 동작하게 되었습니다.

## 장기적 해결 방안
개인적인 저의 관점으로 현재 session_token 컬럼과 인덱스를 추가한 것이 장기적인 관점에서 성능 저하를 많이 일으킬 수 있는 설계라고 생각됩니다.
현재 설계된 것처럼 운영할 경우 소규모 데이터에서는 문제 없이 돌아갈 수 있지만 데이터가 쌓일수록 성능에 문제가 크게 발생할 것입니다.
- 인덱스 크기
  - JWT는 긴 문자열(100~300바이트)이라 인덱스 엔트리 하나당 저장 공간이 큽니다.
  - MySQL InnoDB에서 인덱스 키 크기는 최대 3072바이트로 제한되지만, 긴 키는 B-Tree 노드에 더 적은 엔트리를 저장하게 되어 인덱스 트리가 깊어지고 메모리 사용량이 증가합니다.
- 성능 저하
  - 레코드 수가 증가할수록 인덱스 크기가 비례해 커지고, 검색/삽입/삭제 시 I/O 비용이 증가합니다.
  - 문자열 비교는 정수 비교보다 느리며, 캐시 효율성도 떨어집니다.
 
따라서 토큰을 데이터베이스에 저장하지 않고 토큰에 관련 레코드 정보(id)를 저장하여 설계하는 것이 좋은 설계라고 생각됩니다.
- 인덱스 크기 최적화
  - INT (4바이트) 또는 BIGINT (8바이트)는 JWT 문자열(100~300바이트)에 비해 훨씬 작습니다.
  - 인덱스 크기가 작아 메모리 사용량이 줄고, B-Tree 깊이가 얕아져 검색 속도가 빨라집니다.
- 성능 향상
  - 정수 비교는 문자열 비교보다 빠르며, CPU 캐시 효율이 높습니다.
  - 삽입/삭제 시 인덱스 유지 비용도 낮아집니다.
- 유연성
  - 토큰이 만료되더라도 id는 변하지 않으므로, 토큰 정보와 로그인 데이터 관리가 분리되어 안정적입니다.
 
하지만 위처럼 레코드 정보(id)를 토큰에 저장하기 위해서는 토큰 생성 전에 DB 레코드를 생성하여 id 를 추출해야하기에 때문에 추가 DB 요청이 필요해 요청당 레이턴시가 약간 늘어날 수 있습니다.
이를 개선할 수 있는 방법으로 `JWT 표준에서 제공하는 jti (JWT ID)를 고유 식별자`를 활용하여 범용키(uuid) 또는 해싱키를 활용해 jti와 테이블의 primary key로 활용해볼 수 있습니다.
이렇게 했을 경우 이 `jti(JWT ID)` 를 통해 불필요한 DB 요청을 줄이고 성능 및 유연성의 장점을 가질 수 있을 것 같습니다.

## 추가 고려 사항
이번 사례에서 확인된 인덱스 길이 제한 문제는 데이터베이스 설계 시 중요한 고려 요소입니다. 특히, 긴 문자열을 저장하는 varchar 컬럼이 인덱스에 포함될 경우, 문자셋에 따른 바이트 수를 정확히 계산해야 합니다.
- utf8mb3 대신 utf8mb4(최대 4바이트)를 사용할 경우, 최대 길이는 더 줄어들 수 있습니다(n ≤ 764).
- 인덱스에 불필요한 컬럼이 포함되어 있다면, 인덱스 구성을 재검토하여 키 길이를 최적화할 수 있습니다.

## 결론
데이터베이스 인덱스의 최대 키 길이 제한(3072바이트)은 컬럼 설계와 인덱스 설계 시 반드시 고려해야 할 제약 조건입니다. 이번 이슈를 통해, 문자열 컬럼 길이와 인덱스 구성 간의 관계를 명확히 이해하고, 데이터 타입 및 문자셋에 따른 바이트 계산을 기반으로 적절한 설계를 적용하는 것이 중요하다는 교훈을 얻었습니다. 이를 통해 안정적인 시스템 운영과 문제 예방이 가능해졌습니다.
